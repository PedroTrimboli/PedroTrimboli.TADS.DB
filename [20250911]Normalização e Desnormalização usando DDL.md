# üè≠ Concreto+ ‚Äî Estudo de Caso Banco de Dados

## 1. Contexto Empresarial (Caso de Produ√ß√£o)

**Entidades identificadas:**
- Cliente (quem compra os lotes)
- Funcion√°rio (quem trabalha nos lotes)
- Ve√≠culo (transporta o concreto)
- Material (cimento, areia, brita, aditivo)
- Receita (tipo de concreto e suas quantidades de material)
- Lote (produ√ß√£o feita em certa data)
- Remessa (entrega de um lote para um cliente)

**Relacionamentos principais:**
- Receita √© formada por v√°rios Materiais (N:N).
- Lote usa uma Receita e envolve v√°rios Funcion√°rios (N:N).
- Remessa leva um Lote at√© um Cliente usando um Ve√≠culo.

---

## 2 ‚Äî Direcionamentos para o Aluno

## Etapa 1: Mapeamento Conceitual

### Entidades principais e atributos relevantes
- **Cliente** ‚Üí id, nome/raz√£o social, CNPJ, contato  
- **Funcion√°rio** ‚Üí id, nome, cargo/fun√ß√£o  
- **Ve√≠culo** ‚Üí id, placa, tipo, capacidade  
- **Material** ‚Üí id, nome, unidade (kg/l)  
- **Receita** ‚Üí id, nome, tipo de concreto (comum, armado etc.)  
- **Receita_Item** (tabela de liga√ß√£o) ‚Üí id_receita, id_material, quantidade (kg/ton)  
- **Lote** ‚Üí id, data_producao, quantidade_t, status (produzido, entregue, cancelado)  
- **Lote_Funcion√°rio** (tabela de liga√ß√£o) ‚Üí id_lote, id_funcionario, fun√ß√£o no lote  
- **Remessa** ‚Üí id, data_saida, quantidade, status, id_cliente, id_veiculo, id_lote  

---

### Relacionamentos identificados
- **Receita ‚Äì Material (N:M)**: cada receita usa v√°rios materiais, e cada material pode estar em v√°rias receitas. ‚Üí Resolvido pela entidade **Receita_Item**.  
- **Receita ‚Äì Lote (1:N)**: um lote segue apenas uma receita, mas uma receita pode ser usada em v√°rios lotes.  
- **Lote ‚Äì Funcion√°rio (N:M)**: v√°rios funcion√°rios podem trabalhar em um lote, e um funcion√°rio pode atuar em v√°rios lotes. ‚Üí Resolvido pela entidade **Lote_Funcion√°rio**.  
- **Lote ‚Äì Remessa (1:N)**: um lote pode ser dividido em v√°rias remessas.  
- **Remessa ‚Äì Cliente (N:1)**: cada remessa √© destinada a um cliente, mas um cliente pode ter v√°rias remessas.  
- **Remessa ‚Äì Ve√≠culo (N:1)**: cada remessa √© transportada por um ve√≠culo, mas um ve√≠culo pode realizar v√°rias remessas.  

---

## Etapa 2: Projeto do Diagrama Entidade-Relacionamento (DER) Conceitual

![DER Concreto+](https://private-user-images.githubusercontent.com/74316819/489341579-437260b1-1b25-438b-b81e-b155bae866c9.png?...)

## Etapa 3: Modelo L√≥gico (Diagrama Conceitual)

### Tabela: Cliente
- **id_cliente** (PK) ‚Üí NUMBER  
- nome ‚Üí VARCHAR(100) NOT NULL  
- cnpj ‚Üí VARCHAR(20) UNIQUE  
- contato ‚Üí VARCHAR(100)

---

### Tabela: Funcion√°rio
- **id_funcionario** (PK) ‚Üí NUMBER  
- nome ‚Üí VARCHAR(100) NOT NULL  
- cargo ‚Üí VARCHAR(50)

---

### Tabela: Ve√≠culo
- **id_veiculo** (PK) ‚Üí NUMBER  
- placa ‚Üí VARCHAR(10) NOT NULL UNIQUE  
- tipo ‚Üí VARCHAR(30)  
- capacidade ‚Üí NUMBER CHECK (capacidade > 0)

---

### Tabela: Material
- **id_material** (PK) ‚Üí NUMBER  
- nome ‚Üí VARCHAR(50) NOT NULL  
- unidade ‚Üí VARCHAR(5) CHECK (unidade IN ('KG','L'))

---

### Tabela: Receita
- **id_receita** (PK) ‚Üí NUMBER  
- nome ‚Üí VARCHAR(50) NOT NULL UNIQUE  
- tipo ‚Üí VARCHAR(30)

---

### Tabela: Receita_Item (associa√ß√£o N:M)
- **id_receita** (PK, FK ‚Üí Receita)  
- **id_material** (PK, FK ‚Üí Material)  
- quantidade ‚Üí NUMBER NOT NULL CHECK (quantidade > 0)

---

### Tabela: Lote
- **id_lote** (PK) ‚Üí NUMBER  
- data_producao ‚Üí DATE NOT NULL  
- quantidade ‚Üí NUMBER NOT NULL CHECK (quantidade > 0)  
- status ‚Üí VARCHAR(20) CHECK (status IN ('PRODUZIDO','ENTREGUE','CANCELADO'))  
- id_receita (FK ‚Üí Receita)

---

### Tabela: Lote_Funcion√°rio (associa√ß√£o N:M)
- **id_lote** (PK, FK ‚Üí Lote)  
- **id_funcionario** (PK, FK ‚Üí Funcion√°rio)  
- fun√ß√£o ‚Üí VARCHAR(50)

---

### Tabela: Remessa
- **id_remessa** (PK) ‚Üí NUMBER  
- data_saida ‚Üí DATE NOT NULL  
- quantidade ‚Üí NUMBER NOT NULL CHECK (quantidade > 0)  
- status ‚Üí VARCHAR(20) CHECK (status IN ('EM_TRANSITO','ENTREGUE','CANCELADA'))  
- id_cliente (FK ‚Üí Cliente)  
- id_veiculo (FK ‚Üí Ve√≠culo)  
- id_lote (FK ‚Üí Lote)

---

## Normaliza√ß√£o
- Todos os atributos n√£o-chave dependem inteiramente da chave prim√°ria.  
- Nas tabelas de associa√ß√£o (**Receita_Item**, **Lote_Funcion√°rio**), a PK √© composta e os atributos (`quantidade`, `fun√ß√£o`) dependem da chave inteira ‚Üí n√£o h√° depend√™ncia parcial.  
- N√£o h√° depend√™ncias transitivas.

---

## Etapa 4: Implementa√ß√£o F√≠sica (DDL Oracle SQL)

```sql
CREATE TABLE cliente (
  id_cliente NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  nome       VARCHAR2(100) NOT NULL,
  cnpj       VARCHAR2(20) UNIQUE,
  contato    VARCHAR2(100)
);

CREATE TABLE funcionario (
  id_funcionario NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  nome           VARCHAR2(100) NOT NULL,
  cargo          VARCHAR2(50)
);

CREATE TABLE veiculo (
  id_veiculo NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  placa      VARCHAR2(10) NOT NULL UNIQUE,
  tipo       VARCHAR2(30),
  capacidade NUMBER CHECK (capacidade > 0)
);

CREATE TABLE material (
  id_material NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  nome        VARCHAR2(50) NOT NULL,
  unidade     VARCHAR2(5) CHECK (unidade IN ('KG','L'))
);

CREATE TABLE receita (
  id_receita NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  nome       VARCHAR2(50) NOT NULL UNIQUE,
  tipo       VARCHAR2(30)
);

CREATE TABLE receita_item (
  id_receita  NUMBER NOT NULL,
  id_material NUMBER NOT NULL,
  quantidade  NUMBER NOT NULL CHECK (quantidade > 0),
  CONSTRAINT pk_receita_item PRIMARY KEY (id_receita, id_material),
  CONSTRAINT fk_ri_receita FOREIGN KEY (id_receita) REFERENCES receita(id_receita),
  CONSTRAINT fk_ri_material FOREIGN KEY (id_material) REFERENCES material(id_material)
);

CREATE TABLE lote (
  id_lote      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  data_producao DATE NOT NULL,
  quantidade    NUMBER NOT NULL CHECK (quantidade > 0),
  status        VARCHAR2(20) CHECK (status IN ('PRODUZIDO','ENTREGUE','CANCELADO')),
  id_receita    NUMBER NOT NULL,
  CONSTRAINT fk_lote_receita FOREIGN KEY (id_receita) REFERENCES receita(id_receita)
);

CREATE TABLE lote_funcionario (
  id_lote        NUMBER NOT NULL,
  id_funcionario NUMBER NOT NULL,
  funcao         VARCHAR2(50),
  CONSTRAINT pk_lote_funcionario PRIMARY KEY (id_lote, id_funcionario),
  CONSTRAINT fk_lf_lote FOREIGN KEY (id_lote) REFERENCES lote(id_lote),
  CONSTRAINT fk_lf_func FOREIGN KEY (id_funcionario) REFERENCES funcionario(id_funcionario)
);

CREATE TABLE remessa (
  id_remessa NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  data_saida DATE NOT NULL,
  quantidade NUMBER NOT NULL CHECK (quantidade > 0),
  status     VARCHAR2(20) CHECK (status IN ('EM_TRANSITO','ENTREGUE','CANCELADA')),
  id_cliente NUMBER NOT NULL,
  id_veiculo NUMBER NOT NULL,
  id_lote    NUMBER NOT NULL,
  CONSTRAINT fk_re_cliente FOREIGN KEY (id_cliente) REFERENCES cliente(id_cliente),
  CONSTRAINT fk_re_veiculo FOREIGN KEY (id_veiculo) REFERENCES veiculo(id_veiculo),
  CONSTRAINT fk_re_lote FOREIGN KEY (id_lote) REFERENCES lote(id_lote)
); ```

---

## Etapa 5: Desnormaliza√ß√£o Estrat√©gica (B√¥nus Cr√≠tico)

Para facilitar relat√≥rios de BI, podemos criar uma tabela **redundante**, que junta informa√ß√µes de v√°rias tabelas em uma s√≥.  
Essa tabela **n√£o √© usada no sistema transacional**, apenas em consultas anal√≠ticas.

### Proposta: Tabela `dm_relatorio_producao`

```sql
CREATE TABLE dm_relatorio_producao (
  id_relatorio   NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  data_producao  DATE NOT NULL,
  cliente_nome   VARCHAR2(100) NOT NULL,   -- redundante
  receita_nome   VARCHAR2(50) NOT NULL,    -- redundante
  tipo_concreto  VARCHAR2(30) NOT NULL,    -- redundante
  veiculo_placa  VARCHAR2(10),             -- redundante
  quantidade     NUMBER NOT NULL,
  valor_total    NUMBER NOT NULL,
  status_entrega VARCHAR2(20)
); ```

---

## Etapa 6: Reflex√£o Final (Entrega Escrita)

1. **Por que a normaliza√ß√£o foi essencial para a integridade dos dados da f√°brica?**  
   A normaliza√ß√£o elimina redund√¢ncias (como nomes de clientes ou materiais repetidos em v√°rias linhas) e garante consist√™ncia nas atualiza√ß√µes. Assim, qualquer altera√ß√£o √© feita em um √∫nico ponto, evitando erros e dados contradit√≥rios. Al√©m disso, facilita a integridade referencial, garantindo que n√£o existam registros ‚Äúsoltos‚Äù sem v√≠nculo.

2. **Em que situa√ß√µes a desnormaliza√ß√£o se torna uma escolha estrat√©gica, e n√£o um erro?**  
   A desnormaliza√ß√£o √© estrat√©gica quando o objetivo √© melhorar o desempenho em consultas de leitura intensiva, como relat√≥rios de BI e dashboards gerenciais. Nestes casos, sacrifica-se a integridade r√≠gida em prol da performance, mas apenas em tabelas auxiliares de an√°lise, nunca no sistema transacional.

3. **Quais riscos a tabela desnormalizada pode trazer? Como voc√™ mitigaria esses riscos?**  
   O principal risco √© a diverg√™ncia entre os dados normalizados (fonte oficial) e os dados desnormalizados (c√≥pias redundantes). Isso pode gerar relat√≥rios incorretos se a atualiza√ß√£o n√£o for bem controlada. Para mitigar, pode-se usar processos de ETL agendados, materialized views com refresh autom√°tico e rotinas de valida√ß√£o para garantir que os dados anal√≠ticos estejam sempre sincronizados.

4. **Qual seria o impacto de n√£o aplicar a BCNF neste cen√°rio?**  
   Sem a BCNF, poderiam existir determinantes que n√£o s√£o chaves, gerando anomalias de inser√ß√£o, atualiza√ß√£o e exclus√£o. Isso comprometeria a consist√™ncia da base, podendo resultar em pre√ßos incorretos, lotes duplicados ou materiais mal associados. Em um ambiente de produ√ß√£o e log√≠stica, esses erros teriam impacto direto na qualidade e nos custos da opera√ß√£o.
